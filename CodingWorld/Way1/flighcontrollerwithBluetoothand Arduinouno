#include <Wire.h>
#include <SoftwareSerial.h>
#include <Servo.h> // Include the Servo library


#include <MPU6050.h>
MPU6050 mpu;


SoftwareSerial Bluetooth(3, 4); // RX, TX for Bluetooth
char packet[7];
boolean recvState;
int ESCout_1 = 5, ESCout_2 = 6, ESCout_3 = 7, ESCout_4 = 8;
int input_PITCH = 50;
int input_ROLL = 50;
int input_YAW;
int input_THROTTLE = 1100;
int state1, state2, state3, state4;
int16_t gyro_x, gyro_y, gyro_z, acc_x, acc_y, acc_z, temperature, acc_total_vector;
float angle_pitch, angle_roll, angle_yaw;
boolean set_gyro_angles;
float angle_roll_acc, angle_pitch_acc;
float angle_pitch_output, angle_roll_output;
float elapsedTime;
long Time, timePrev, time2;
long gyro_x_cal, gyro_y_cal, gyro_z_cal;
float pitch_PID, roll_PID, yaw_PID;
float roll_error, roll_previous_error, pitch_error, pitch_previous_error, yaw_error;
float roll_pid_p, roll_pid_d, roll_pid_i, pitch_pid_p, pitch_pid_i, pitch_pid_d, yaw_pid_p, yaw_pid_i;
float roll_desired_angle, pitch_desired_angle, yaw_desired_angle;
double twoX_kp = 5;
double twoX_ki = 0.003;
double twoX_kd = 2;
double yaw_kp = 3;
double yaw_ki = 0.002;

Servo esc1; // Create Servo objects for ESCs
Servo esc2;
Servo esc3;
Servo esc4;

void setup() {
  Serial.begin(9600);
  Bluetooth.begin(9600); // Initialize Bluetooth Serial

  Wire.begin();
  Wire.setClock(400000);
  Wire.beginTransmission(0x68);

  Wire.write(0x6B);
  Wire.write(0x00);
  Wire.endTransmission();

  Wire.beginTransmission(0x68);
  Wire.write(0x1C);
  Wire.write(0x10);
  Wire.endTransmission();

  Wire.beginTransmission(0x68);
  Wire.write(0x1B);
  Wire.write(0x08);

  Wire.endTransmission();
  delay(1000);

  // Attach ESCs to PWM pins
  esc1.attach(ESCout_1);
  esc2.attach(ESCout_2);
  esc3.attach(ESCout_3);
  esc4.attach(ESCout_4);

  // ESC Calibration
  calibrateESC();
  Time = micros();
}

void calibrateESC() {
  Serial.println("Calibrating ESC...");

  // Send minimum signal to all ESCs
  esc1.writeMicroseconds(1000);
  esc2.writeMicroseconds(1000);
  esc3.writeMicroseconds(1000);
  esc4.writeMicroseconds(1000);
  delay(2000); // Wait for ESCs to initialize

  // Send maximum signal to all ESCs
  esc1.writeMicroseconds(2000);
  esc2.writeMicroseconds(2000);
  esc3.writeMicroseconds(2000);
  esc4.writeMicroseconds(2000);
  delay(2000); // Wait for ESCs to calibrate

  // Set ESCs to neutral
  esc1.writeMicroseconds(1050);
  esc2.writeMicroseconds(1050);
  esc3.writeMicroseconds(1050);
  esc4.writeMicroseconds(1050);
  Serial.println("Calibrating Done");
}

void loop() {
  // Timing
  Serial.print("hello1");
  Time = micros();
  elapsedTime = (float)(Time - timePrev) / (float)1000000;
  timePrev = Time;

  // Read sensor data

  Wire.beginTransmission(0x68);
  Wire.write(0x3B);
  Wire.endTransmission();
  Wire.requestFrom(0x68, 14);


    Serial.print("hello2");


  while (Wire.available() < 14);


  acc_x = Wire.read() << 8 | Wire.read();
  acc_y = Wire.read() << 8 | Wire.read();
  acc_z = Wire.read() << 8 | Wire.read();
  temperature = Wire.read() << 8 | Wire.read();
  gyro_x = Wire.read() << 8 | Wire.read();
  gyro_y = Wire.read() << 8 | Wire.read();
  gyro_z = Wire.read() << 8 | Wire.read();
  gyro_x -= gyro_x_cal;
  gyro_y -= gyro_y_cal;
  gyro_z -= gyro_z_cal;

    Serial.print("hello3");


  angle_pitch += gyro_x * elapsedTime * 0.01526717557;
  angle_roll += gyro_y * elapsedTime * 0.01526717557;
  angle_yaw += gyro_z * elapsedTime * 0.01526717557;
  angle_pitch += angle_roll * sin(gyro_z * 0.000001066);
  angle_roll -= angle_pitch * sin(gyro_z * 0.000001066);
  acc_total_vector = sqrt((acc_x * acc_x) + (acc_y * acc_y) + (acc_z * acc_z));
  angle_pitch_acc = asin((float)acc_y / acc_total_vector) * 57.296;
  angle_roll_acc = asin((float)acc_x / acc_total_vector) * -57.296;
  if (set_gyro_angles) {
    angle_pitch = angle_pitch * 0.9996 + angle_pitch_acc * 0.0004;
    angle_roll = angle_roll * 0.9996 + angle_roll_acc * 0.0004;
  } else {
    angle_pitch = angle_pitch_acc;
    angle_roll = angle_roll_acc;
    set_gyro_angles = true;
  }
  angle_pitch_output = angle_pitch_output * 0.9 + angle_pitch * 0.1;
  angle_roll_output = angle_roll_output * 0.9 + angle_roll * 0.1;


    Serial.print("hello4 pid");


  // PID calculations
  roll_desired_angle = 3 * ((float)input_ROLL / (float)10 - (float)5);
  pitch_desired_angle = 3 * ((float)input_PITCH / (float)10 - (float)5);
  roll_error = angle_roll_output - roll_desired_angle;
  pitch_error = angle_pitch_output - pitch_desired_angle;
  yaw_error = angle_yaw - yaw_desired_angle;
  roll_pid_p = twoX_kp * roll_error;
  pitch_pid_p = twoX_kp * pitch_error;
  yaw_pid_p = yaw_kp * yaw_error;
  if (-3 < roll_error < 3) { roll_pid_i = roll_pid_i + (twoX_ki * roll_error); }
  if (-3 < pitch_error < 3) { pitch_pid_i = pitch_pid_i + (twoX_ki * pitch_error); }
  if (-3 < yaw_error < 3) { yaw_pid_i = yaw_pid_i + (yaw_ki * yaw_error); }
  roll_pid_d = twoX_kd * ((roll_error - roll_previous_error) / elapsedTime);
  pitch_pid_d = twoX_kd * ((pitch_error - pitch_previous_error) / elapsedTime);
  roll_PID = roll_pid_p + roll_pid_i + roll_pid_d;
  pitch_PID = pitch_pid_p + pitch_pid_i + pitch_pid_d;
  yaw_PID = yaw_pid_p + yaw_pid_i;
  if (roll_PID < -400) { roll_PID = -400; } else if (roll_PID > 400) { roll_PID = 400; }
  if (pitch_PID < -400) { pitch_PID = -400; } else if (pitch_PID > 400) { pitch_PID = 400; }
  if (yaw_PID < -400) { yaw_PID = -400; } else if (yaw_PID > 400) { yaw_PID = 400; }
  int pwm1 = input_THROTTLE - roll_PID - pitch_PID - yaw_PID;
  int pwm2 = input_THROTTLE + roll_PID - pitch_PID + yaw_PID;
  int pwm3 = input_THROTTLE + roll_PID + pitch_PID - yaw_PID;
  int pwm4 = input_THROTTLE - roll_PID + pitch_PID + yaw_PID;
  pwm1 = constrain(pwm1, 1100, 2000);
  pwm2 = constrain(pwm2, 1100, 2000);
  pwm3 = constrain(pwm3, 1100, 2000);
  pwm4 = constrain(pwm4, 1100, 2000);


      Serial.print("hello5");

  // // Set PWM output for ESCs
  esc1.writeMicroseconds(pwm1);
  esc2.writeMicroseconds(pwm2);
  esc3.writeMicroseconds(pwm3);
  esc4.writeMicroseconds(pwm4);

  // Bluetooth communication
  if (!recvState) {
    if (Bluetooth.available()) {
      int len = Bluetooth.readBytes(packet, 6);
      packet[len] = '\0';
      if (String(packet[0]) == "a") {
        input_ROLL = int(packet[1]);
        input_PITCH = int(packet[2]);
        input_THROTTLE = 1000 + int(packet[3]);
        input_YAW = int(packet[4]);
      } else if (String(packet[0]) == "b") {
        input_ROLL = int(packet[1]);
        input_PITCH = int(packet[2]);
        input_THROTTLE = 1000 + int(packet[3]) * 100 + int(packet[4]);
        input_YAW = int(packet[5]);
      }
      if (String(packet[0]) == "1") {
        twoX_kp = (float)int(packet[1]) / (float)100;
        twoX_ki = (float)int(packet[2]) / (float)1000;
        twoX_kd = (float)int(packet[3]) / (float)100;
      } else if (String(packet[0]) == "2") {
        twoX_kp = (float)(int(packet[1]) * 100 + int(packet[2])) / (float)100;
        twoX_ki = (float)(int(packet[3]) * 100 + int(packet[4])) / (float)1000;
        twoX_kd = (float)(int(packet[5]) * 100 + int(packet[6])) / (float)100;
      } // Add other cases as needed
      Serial.print(input_ROLL); Serial.print(" ");
      Serial.print(input_THROTTLE); Serial.print(" ");
      Serial.print(twoX_kp); Serial.print(" ");
      Serial.print(twoX_ki, 3); Serial.print(" ");
      Serial.print(twoX_kd); Serial.println();
    }
  } else if (recvState) {
    Bluetooth.print(Time - timePrev);
  }
  recvState = !recvState;

  // Debug output
  Serial.print(angle_roll_output); Serial.print("  ");
  Serial.print(angle_pitch_output); Serial.print(" | ");
  Serial.print(roll_desired_angle); Serial.print("  ");
  Serial.print(pitch_desired_angle);
  Serial.println("jhgj");
}
